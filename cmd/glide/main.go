package main

import (
	stdcontext "context"
	"fmt"
	"log/slog"
	"os"
	"time"

	cliPkg "github.com/ivannovak/glide/v3/internal/cli"
	"github.com/ivannovak/glide/v3/internal/config"
	"github.com/ivannovak/glide/v3/internal/context"
	"github.com/ivannovak/glide/v3/pkg/branding"
	glideErrors "github.com/ivannovak/glide/v3/pkg/errors"
	"github.com/ivannovak/glide/v3/pkg/logging"
	"github.com/ivannovak/glide/v3/pkg/output"
	"github.com/ivannovak/glide/v3/pkg/plugin"
	"github.com/ivannovak/glide/v3/pkg/update"
	"github.com/ivannovak/glide/v3/pkg/version"
	"github.com/spf13/cobra"
)

var (
	// CLI flags
	cfgFile   string
	debugMode bool

	// Global output flags
	outputFormat string
	quietMode    bool
	noColor      bool

	// Update notification
	updateNotificationManager *update.NotificationManager
	updateCheckResult         <-chan *update.UpdateInfo
)

func main() {
	if err := Execute(); err != nil {
		// Use the new error handler for consistent error display
		os.Exit(glideErrors.Print(err))
	}
}

func Execute() error {
	// Initialize logging from environment variables
	logging.SetDefault(logging.New(logging.FromEnv()))

	logging.Debug("Starting glide", "version", version.GetVersionString())

	// Version information is set via ldflags at build time directly in the version package

	// Load configuration
	cfg, err := config.Load()
	if err != nil && !os.IsNotExist(err) {
		logging.Error("Failed to load configuration", "error", err)
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Start background update check if enabled
	startUpdateCheck(cfg)

	// Get list of registered plugins for context detection
	// We pass them as interface{} to avoid import cycles
	pluginList := plugin.List()
	extensionProviders := make([]interface{}, len(pluginList))
	for i, p := range pluginList {
		extensionProviders[i] = p
	}

	// Detect project context with plugin extensions
	ctx := context.DetectWithExtensions(extensionProviders)

	// Create output manager directly
	outputManager := output.NewManager(
		output.FormatTable, // Default format, will be overridden by flags
		false,              // quiet
		false,              // noColor
		os.Stdout,
	)

	// Set global manager for backward compatibility during migration
	output.SetGlobalManager(outputManager)

	// Create root command
	rootCmd := &cobra.Command{
		Use:                   branding.CommandName,
		Short:                 branding.GetShortDescription(),
		Long:                  branding.GetFullDescription(),
		Version:               version.Get(),
		SilenceErrors:         true, // We handle errors ourselves
		SilenceUsage:          true, // Don't show usage on error
		DisableAutoGenTag:     true, // Disable "Auto generated by spf13/cobra" in docs
		DisableFlagsInUseLine: false,
		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
			// Handle debug mode
			if debugMode || os.Getenv("GLIDE_DEBUG") != "" {
				logging.SetLevel(slog.LevelDebug)
				logging.Debug("Debug mode enabled")
			}

			// Parse output format
			format, err := output.ParseFormat(outputFormat)
			if err != nil {
				return fmt.Errorf("invalid output format: %w", err)
			}

			// Check environment variables if flags not set
			if !cmd.Flags().Changed("no-color") && os.Getenv("NO_COLOR") != "" {
				noColor = true
			}

			// Update the output manager with the command-line flags
			outputManager.SetFormat(format)
			outputManager.SetQuiet(quietMode)
			outputManager.SetNoColor(noColor)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			if len(args) == 0 {
				return cmd.Help()
			}

			// This shouldn't be reached for valid commands, but provides fallback
			return cliPkg.ShowUnknownCommandError(args[0], ctx, cfg)
		},
	}

	// Global flags
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", fmt.Sprintf("config file (default is $HOME/%s)", branding.ConfigFileName))
	rootCmd.PersistentFlags().BoolVar(&debugMode, "debug", false, "Enable debug logging (equivalent to GLIDE_LOG_LEVEL=debug)")
	rootCmd.PersistentFlags().StringVar(&outputFormat, "format", "table", "Output format (table, json, yaml, plain)")
	rootCmd.PersistentFlags().BoolVarP(&quietMode, "quiet", "q", false, "Suppress non-error output")
	rootCmd.PersistentFlags().BoolVar(&noColor, "no-color", false, "Disable colored output")

	// Initialize CLI with dependencies
	cli := cliPkg.New(outputManager, ctx, cfg)

	// Add local commands (includes setup, config, plugins, help, global, and all other registered commands)
	cli.AddLocalCommands(rootCmd)

	// Disable Cobra's default help command since we have our own
	rootCmd.SetHelpCommand(&cobra.Command{
		Use:    "no-help",
		Hidden: true,
	})

	// Set custom help function to use our enhanced help
	rootCmd.SetHelpFunc(func(cmd *cobra.Command, args []string) {
		// Use our custom help command's ShowHelp method
		hc := &cliPkg.HelpCommand{
			ProjectContext: ctx,
			Config:         cfg,
		}
		if err := hc.ShowHelp(cmd); err != nil {
			fmt.Fprintf(os.Stderr, "Error displaying help: %v\n", err)
		}
	})

	// Load plugins
	// NOTE: Plugin configurations are loaded from YAML by internal/config/loader.go
	// and synced to the typed config registry (pkg/config).
	// Plugins access their typed configs using config.Get[T](pluginName).

	// Set standard context for cancellation/deadline support
	rootCmd.SetContext(stdcontext.Background())

	// Load all registered build-time plugins
	result, err := plugin.LoadAll(rootCmd)
	if err != nil {
		// Fatal error during plugin loading
		return fmt.Errorf("failed to load build-time plugins: %w", err)
	}

	// Report non-fatal plugin errors to user
	if result != nil && result.HasErrors() && !quietMode {
		fmt.Fprintf(os.Stderr, "%s\n", result.ErrorMessage())
	}

	// Load runtime plugins
	runtimeResult, err := plugin.LoadAllRuntimePlugins(rootCmd)
	if err != nil {
		// Fatal error during runtime plugin loading
		return fmt.Errorf("failed to load runtime plugins: %w", err)
	}

	// Report non-fatal runtime plugin errors to user
	if runtimeResult != nil && runtimeResult.HasErrors() && !quietMode {
		fmt.Fprintf(os.Stderr, "%s\n", runtimeResult.ErrorMessage())
	}

	// Register completions for all commands
	cli.RegisterCompletions(rootCmd)

	// Enable command suggestions for typos
	rootCmd.SuggestionsMinimumDistance = 1

	// Execute root command
	cmdErr := rootCmd.Execute()

	// Show update notification after command completes (if not in quiet mode)
	if !quietMode {
		showUpdateNotification(cfg)
	}

	return cmdErr
}

// startUpdateCheck initializes the update notification manager and starts background check
func startUpdateCheck(cfg *config.Config) {
	// Check if updates are disabled via config
	if cfg != nil && !cfg.Defaults.Update.CheckEnabled {
		logging.Debug("Update checks disabled in configuration")
		return
	}

	// Check if disabled via environment variable
	if os.Getenv("GLIDE_NO_UPDATE_CHECK") != "" {
		logging.Debug("Update checks disabled via GLIDE_NO_UPDATE_CHECK")
		return
	}

	// Get check interval from config (default to 24 hours)
	checkInterval := update.DefaultCheckInterval
	if cfg != nil && cfg.Defaults.Update.CheckIntervalHours > 0 {
		checkInterval = time.Duration(cfg.Defaults.Update.CheckIntervalHours) * time.Hour
	}

	// Create notification config
	notifyConfig := &update.NotificationConfig{
		Enabled:       true,
		CheckInterval: checkInterval,
	}

	// Initialize notification manager
	updateNotificationManager = update.NewNotificationManager(version.Get(), notifyConfig)

	// Only check if enough time has passed
	if updateNotificationManager.ShouldCheck() {
		logging.Debug("Starting background update check")
		updateCheckResult = updateNotificationManager.CheckForUpdateAsync(stdcontext.Background())
	} else {
		logging.Debug("Skipping update check, checked recently")
	}
}

// showUpdateNotification displays update notification if an update is available
func showUpdateNotification(cfg *config.Config) {
	// Check if notifications are disabled
	if cfg != nil && !cfg.Defaults.Update.NotifyEnabled {
		return
	}

	if updateNotificationManager == nil {
		return
	}

	var info *update.UpdateInfo

	// Wait for async check to complete (channel closes when done)
	// The check has its own 3s timeout, so this won't block long
	if updateCheckResult != nil {
		result, ok := <-updateCheckResult
		if ok && result != nil {
			info = result
		}
	}

	// Fall back to cached info
	if info == nil {
		info = updateNotificationManager.GetCachedUpdateInfo()
	}

	// Display notification if update available
	if info != nil && info.Available {
		fmt.Fprint(os.Stderr, update.FormatNotification(info))
		updateNotificationManager.MarkNotified(info.LatestVersion)
	}
}
