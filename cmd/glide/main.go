package main

import (
	stdcontext "context"
	"fmt"
	"log/slog"
	"os"

	cliPkg "github.com/ivannovak/glide/v3/internal/cli"
	"github.com/ivannovak/glide/v3/internal/config"
	"github.com/ivannovak/glide/v3/internal/context"
	"github.com/ivannovak/glide/v3/pkg/branding"
	glideErrors "github.com/ivannovak/glide/v3/pkg/errors"
	"github.com/ivannovak/glide/v3/pkg/logging"
	"github.com/ivannovak/glide/v3/pkg/output"
	"github.com/ivannovak/glide/v3/pkg/plugin"
	"github.com/ivannovak/glide/v3/pkg/version"
	"github.com/spf13/cobra"
)

var (
	// CLI flags
	cfgFile   string
	debugMode bool

	// Global output flags
	outputFormat string
	quietMode    bool
	noColor      bool
)

func main() {
	if err := Execute(); err != nil {
		// Use the new error handler for consistent error display
		os.Exit(glideErrors.Print(err))
	}
}

func Execute() error {
	// Initialize logging from environment variables
	logging.SetDefault(logging.New(logging.FromEnv()))

	logging.Debug("Starting glide", "version", version.GetVersionString())

	// Version information is set via ldflags at build time directly in the version package

	// Load configuration
	cfg, err := config.Load()
	if err != nil && !os.IsNotExist(err) {
		logging.Error("Failed to load configuration", "error", err)
		return fmt.Errorf("failed to load config: %w", err)
	}

	// Get list of registered plugins for context detection
	// We pass them as interface{} to avoid import cycles
	pluginList := plugin.List()
	extensionProviders := make([]interface{}, len(pluginList))
	for i, p := range pluginList {
		extensionProviders[i] = p
	}

	// Detect project context with plugin extensions
	ctx := context.DetectWithExtensions(extensionProviders)

	// Create output manager directly
	outputManager := output.NewManager(
		output.FormatTable, // Default format, will be overridden by flags
		false,              // quiet
		false,              // noColor
		os.Stdout,
	)

	// Set global manager for backward compatibility during migration
	output.SetGlobalManager(outputManager)

	// Create root command
	rootCmd := &cobra.Command{
		Use:                   branding.CommandName,
		Short:                 branding.GetShortDescription(),
		Long:                  branding.GetFullDescription(),
		Version:               version.Get(),
		SilenceErrors:         true, // We handle errors ourselves
		SilenceUsage:          true, // Don't show usage on error
		DisableAutoGenTag:     true, // Disable "Auto generated by spf13/cobra" in docs
		DisableFlagsInUseLine: false,
		PersistentPreRunE: func(cmd *cobra.Command, args []string) error {
			// Handle debug mode
			if debugMode || os.Getenv("GLIDE_DEBUG") != "" {
				logging.SetLevel(slog.LevelDebug)
				logging.Debug("Debug mode enabled")
			}

			// Parse output format
			format, err := output.ParseFormat(outputFormat)
			if err != nil {
				return fmt.Errorf("invalid output format: %w", err)
			}

			// Check environment variables if flags not set
			if !cmd.Flags().Changed("no-color") && os.Getenv("NO_COLOR") != "" {
				noColor = true
			}

			// Update the output manager with the command-line flags
			outputManager.SetFormat(format)
			outputManager.SetQuiet(quietMode)
			outputManager.SetNoColor(noColor)

			return nil
		},
		RunE: func(cmd *cobra.Command, args []string) error {
			if len(args) == 0 {
				return cmd.Help()
			}

			// This shouldn't be reached for valid commands, but provides fallback
			return cliPkg.ShowUnknownCommandError(args[0], ctx, cfg)
		},
	}

	// Global flags
	rootCmd.PersistentFlags().StringVar(&cfgFile, "config", "", fmt.Sprintf("config file (default is $HOME/%s)", branding.ConfigFileName))
	rootCmd.PersistentFlags().BoolVar(&debugMode, "debug", false, "Enable debug logging (equivalent to GLIDE_LOG_LEVEL=debug)")
	rootCmd.PersistentFlags().StringVar(&outputFormat, "format", "table", "Output format (table, json, yaml, plain)")
	rootCmd.PersistentFlags().BoolVarP(&quietMode, "quiet", "q", false, "Suppress non-error output")
	rootCmd.PersistentFlags().BoolVar(&noColor, "no-color", false, "Disable colored output")

	// Initialize CLI with dependencies
	cli := cliPkg.New(outputManager, ctx, cfg)

	// Add local commands (includes setup, config, plugins, help, global, and all other registered commands)
	cli.AddLocalCommands(rootCmd)

	// Disable Cobra's default help command since we have our own
	rootCmd.SetHelpCommand(&cobra.Command{
		Use:    "no-help",
		Hidden: true,
	})

	// Set custom help function to use our enhanced help
	rootCmd.SetHelpFunc(func(cmd *cobra.Command, args []string) {
		// Use our custom help command's ShowHelp method
		hc := &cliPkg.HelpCommand{
			ProjectContext: ctx,
			Config:         cfg,
		}
		if err := hc.ShowHelp(cmd); err != nil {
			fmt.Fprintf(os.Stderr, "Error displaying help: %v\n", err)
		}
	})

	// Load plugins
	// NOTE: Plugin configurations are loaded from YAML by internal/config/loader.go
	// and synced to the typed config registry (pkg/config).
	// Plugins access their typed configs using config.Get[T](pluginName).

	// Set standard context for cancellation/deadline support
	rootCmd.SetContext(stdcontext.Background())

	// Load all registered build-time plugins
	result, err := plugin.LoadAll(rootCmd)
	if err != nil {
		// Fatal error during plugin loading
		return fmt.Errorf("failed to load build-time plugins: %w", err)
	}

	// Report non-fatal plugin errors to user
	if result != nil && result.HasErrors() && !quietMode {
		fmt.Fprintf(os.Stderr, "%s\n", result.ErrorMessage())
	}

	// Load runtime plugins
	runtimeResult, err := plugin.LoadAllRuntimePlugins(rootCmd)
	if err != nil {
		// Fatal error during runtime plugin loading
		return fmt.Errorf("failed to load runtime plugins: %w", err)
	}

	// Report non-fatal runtime plugin errors to user
	if runtimeResult != nil && runtimeResult.HasErrors() && !quietMode {
		fmt.Fprintf(os.Stderr, "%s\n", runtimeResult.ErrorMessage())
	}

	// Register completions for all commands
	cli.RegisterCompletions(rootCmd)

	// Enable command suggestions for typos
	rootCmd.SuggestionsMinimumDistance = 1

	// Execute root command
	return rootCmd.Execute()
}
